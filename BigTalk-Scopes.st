Object subclass: #AbstractScope	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Scopes'!!AbstractScope methodsFor: 'testing' stamp: 'jws 11/1/2024 11:49'!isBound: aName	"Answer true if aName has a binding in scope."		self subclassResponsibility! !!AbstractScope methodsFor: 'accessing' stamp: 'jws 11/1/2024 11:48'!bind: aNameto: aValue	"Associate a name with a value. Names should be unique within a local scope."		self subclassResponsibility! !!AbstractScope methodsFor: 'accessing' stamp: 'jws 11/1/2024 11:47'!bindingFor: aName	"Answer the value associated with aName."		self subclassResponsibility! !Object subclass: #BTEnvironment	instanceVariableNames: 'variables methods activations'	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Scopes'!!BTEnvironment methodsFor: 'accessing' stamp: 'nl 11/14/2024 15:00'!declare: aNamemethod: aValue	methods bind: aName to: aValue.! !!BTEnvironment methodsFor: 'accessing' stamp: 'nl 11/14/2024 14:55'!declare: aNamevariable: aValue	variables bind: aName to: aValue.! !!BTEnvironment methodsFor: 'accessing' stamp: 'nl 11/14/2024 15:18'!globalScope	^ activations isEmpty		ifTrue: [variables]		ifFalse: [activations first]! !!BTEnvironment methodsFor: 'accessing' stamp: 'nl 11/14/2024 14:55'!hasMethod: aName	^methods isBound: aName.! !!BTEnvironment methodsFor: 'accessing' stamp: 'nl 11/14/2024 14:56'!hasVariable: aName	^variables isBound: aName.! !!BTEnvironment methodsFor: 'initialize-release' stamp: 'nl 11/14/2024 14:43'!initialize	super initialize.	methods := Scope newGlobalScope.	variables := Scope newGlobalScope.	activations := OrderedCollection new.! !!BTEnvironment methodsFor: 'initialize-release' stamp: 'nl 11/14/2024 14:59'!method: aName	^methods bindingFor: aName.	! !!BTEnvironment methodsFor: 'initialize-release' stamp: 'nl 11/14/2024 14:51'!variable: aName	^variables bindingFor: aName.	! !!BTEnvironment methodsFor: 'testing' stamp: 'nl 11/14/2024 15:14'!activate		activations addLast: variables.	variables := Scope newInside: self globalScope.! !!BTEnvironment methodsFor: 'testing' stamp: 'nl 11/14/2024 15:23'!deactivate	variables := activations removeLast.! !TestCase subclass: #BTEnvironmentTestCase	instanceVariableNames: 'env'	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Scopes'!!BTEnvironmentTestCase methodsFor: 'running' stamp: 'jws 11/7/2024 11:37'!testActivation	env declare: 'winkin' variable: 7.	env activate.	self assert: (env hasVariable: 'winkin').	self		assert: 7		equals: (env variable: 'winkin').	env declare: 'winkin' variable: 9.	self 		assert: 9		equals: (env variable: 'winkin').	env declare: 'blinkin' variable: 13.	self assert: (env hasVariable: 'blinkin').	env deactivate.	self		assert: 7		equals: (env variable: 'winkin').	self deny: (env hasVariable: 'blinkin').	! !!BTEnvironmentTestCase methodsFor: 'running' stamp: 'jws 11/7/2024 11:30'!testMethodScope	self		should: [env method: 'jaws']		raise: BTUndeclaredError.	self deny: (env hasMethod: 'jaws').	env declare: 'jaws' method: 42.	self assert: (env hasMethod: 'jaws').	self		assert: 42		equals: (env method: 'jaws').	self		should: [env declare: 'jaws' method: 23]		raise: BTMultipleDeclarationError.	self deny: (env hasVariable: 'jaws').! !!BTEnvironmentTestCase methodsFor: 'running' stamp: 'jws 11/7/2024 11:30'!testVariableScope	| var badVar |	self		should: [env variable: 'jaws']		raise: BTUndeclaredError.	self deny: (env hasVariable: 'jaws').	var := BTVariable boolean.	env declare: 'jaws' variable: var.	self assert: (env hasVariable: 'jaws').	self		assert: var		equals: (env variable: 'jaws').	badVar := BTVariable string.	self		should: [env declare: 'jaws' variable: badVar]		raise: BTMultipleDeclarationError.	self deny: (env hasMethod: 'jaws').! !!BTEnvironmentTestCase methodsFor: 'initialize-release' stamp: 'jws 11/7/2024 11:15'!setUp	super setUp.	env := BTEnvironment new.! !!BTEnvironmentTestCase methodsFor: 'initialize-release' stamp: 'jws 11/7/2024 11:15'!tearDown	env := nil.	super tearDown.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BTEnvironmentTestCase class	instanceVariableNames: 'env'!!BTEnvironmentTestCase class methodsFor: 'initialize-release' stamp: 'jws 11/6/2024 11:46'!setUp	super setUp.	env := BTEnvironment new.	! !AbstractScope subclass: #Scope	instanceVariableNames: 'outerScope bindings'	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Scopes'!!Scope methodsFor: 'accessing' stamp: 'nl 12/7/2024 14:58'!bind: aNameto: aValue		(self bindings includesKey: aName)		ifTrue: [BTMultipleDeclarationError signal: aName].	self bindings at: aName put: aValue.		! !!Scope methodsFor: 'accessing' stamp: 'nl 11/14/2024 11:40'!bindingFor: aName	^bindings at: aName ifAbsent: [outerScope bindingFor: aName].	! !!Scope methodsFor: 'accessing' stamp: 'nl 11/14/2024 11:19'!isBound: aName	^(self bindings includesKey: aName) or: [outerScope isBound: aName].! !!Scope methodsFor: 'initialize-release' stamp: 'nl 11/14/2024 11:20'!bindings	^bindings! !!Scope methodsFor: 'initialize-release' stamp: 'nl 11/13/2024 11:34'!initialize	super initialize.	outerScope := VoidScope default.	bindings := Dictionary new.	! !!Scope methodsFor: 'initialize-release' stamp: 'nl 11/13/2024 11:46'!outerScope: aScope	outerScope := aScope.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Scope class	instanceVariableNames: ''!!Scope class methodsFor: 'accessing' stamp: 'nl 11/14/2024 11:14'!newGlobalScope		^self new.! !!Scope class methodsFor: 'accessing' stamp: 'nl 11/13/2024 11:45'!newInside: targetScope	^self new outerScope: targetScope.! !TestCase subclass: #ScopeTestCase	instanceVariableNames: 'globalScope var1 var2 var3 var4 innerScope'	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Scopes'!!ScopeTestCase methodsFor: 'initialize-release' stamp: 'nl 11/14/2024 11:28'!setUp	super setUp.	globalScope := Scope newGlobalScope.! !!ScopeTestCase methodsFor: 'initialize-release' stamp: 'jws 11/6/2024 11:26'!setupNestedScopes	var1 := BTVariable integer.	var2 := BTVariable boolean.	var3 := BTVariable string.	var4 := BTVariable integer.	globalScope bind: 'cows' to: var1.	globalScope bind: 'pigs' to: var2.	innerScope := Scope newInside: globalScope.	innerScope bind: 'cows' to: var3.	innerScope bind: 'rooster' to: var4! !!ScopeTestCase methodsFor: 'initialize-release' stamp: 'jws 11/6/2024 11:09'!tearDown	globalScope := nil.	super tearDown.! !!ScopeTestCase methodsFor: 'running' stamp: 'jws 11/4/2024 11:49'!testBasicOperation	| whaleVar var |	whaleVar := BTVariable boolean.	self deny: (globalScope isBound: 'Jonah').	globalScope bind: 'Jonah' to: whaleVar.	self assert: (globalScope isBound: 'Jonah').	self		assert: whaleVar		equals: (globalScope bindingFor: 'Jonah').	var := BTVariable integer.	self		should: [globalScope bind: 'Jonah' to: var]		raise: BTMultipleDeclarationError.	self 		should: [globalScope bindingFor: 'Melchezidek']		raise: BTUndeclaredError.	self deny: (globalScope isBound: 'Melchezidek').! !!ScopeTestCase methodsFor: 'running' stamp: 'nl 11/14/2024 11:42'!testNestedScopes	| innerScope inmostScope|	innerScope :=Scope newInside: globalScope.	inmostScope := Scope newInside: innerScope.! !!ScopeTestCase methodsFor: 'running' stamp: 'jws 11/6/2024 11:30'!testNestedScopesBindingFor	self setupNestedScopes.	self		assert: var1		equals: (globalScope bindingFor: 'cows').	self		assert: var2		equals: (globalScope bindingFor: 'pigs').	self		assert: var3		equals: (innerScope bindingFor: 'cows').	self		assert: var4		equals: (innerScope bindingFor: 'rooster').	self		assert: var2		equals: (innerScope bindingFor: 'pigs').! !!ScopeTestCase methodsFor: 'running' stamp: 'jws 11/6/2024 11:33'!testNestedScopesExceptions	| var5 |	var5 := BTVariable string.	self setupNestedScopes.	self		should: [innerScope bind: 'rooster' to: var5]		raise: BTMultipleDeclarationError.	self		deny: (innerScope isBound: 'Unicorn').	self		should: [innerScope bindingFor: 'Unicorn']		raise: BTUndeclaredError! !!ScopeTestCase methodsFor: 'running' stamp: 'jws 11/6/2024 11:35'!testNestedScopesIsBound	self setupNestedScopes.	self assert: (globalScope isBound: 'cows').	self assert: (globalScope isBound: 'pigs').	self assert: (innerScope isBound: 'cows').	self assert: (innerScope isBound: 'rooster').	self assert: (innerScope isBound: 'pigs').	! !AbstractScope subclass: #VoidScope	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Scopes'!!VoidScope methodsFor: 'accessing' stamp: 'nl 12/7/2024 15:11'!bind: aNameto: aValue	"Associate a name with a value. Names should be unique within a local scope."		BTError signal: aName.! !!VoidScope methodsFor: 'accessing' stamp: 'nl 12/7/2024 15:11'!bindingFor: aName	BTUndeclaredError signal: aName.! !!VoidScope methodsFor: 'accessing' stamp: 'nl 11/8/2024 11:37'!isBound: aName	^false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!VoidScope class	instanceVariableNames: 'default'!!VoidScope class methodsFor: 'accessing' stamp: 'nl 11/13/2024 11:36'!default	"lazy initialization"	default isNil ifTrue: [default := self new].	^default! !TestCase subclass: #VoidScopeTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Scopes'!!VoidScopeTestCase methodsFor: 'running' stamp: 'jws 11/4/2024 11:18'!testBindTo	| scope |	scope := VoidScope default.	self		should: [scope bind: 'myVar' to: BTVariable integer]		raise: BTError! !!VoidScopeTestCase methodsFor: 'running' stamp: 'jws 11/4/2024 11:19'!testBindingFor	| scope |	scope := VoidScope default.	self		should: [scope bindingFor: 'myVar']		raise: BTUndeclaredError! !!VoidScopeTestCase methodsFor: 'running' stamp: 'jws 11/4/2024 11:16'!testIsBound	| void |	void := VoidScope default.	self deny: (void isBound: 'myVar').! !!VoidScopeTestCase methodsFor: 'running' stamp: 'jws 11/4/2024 11:15'!testIsSingleton	| void1 void2 |	void1 := VoidScope default.	void2 := VoidScope default.	self assert: (void1 == void2).! !