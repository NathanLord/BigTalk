Object subclass: #ActionsBuilder	instanceVariableNames: 'grammar baseName'	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Parser'!!ActionsBuilder methodsFor: 'meta' stamp: 'jws 11/10/2024 19:30'!compileActionForRule: aRulein: aClass	| srcStream |	srcStream := WriteStream on: String new.	srcStream 		nextPutAll: aRule ruleName;		nextPutAll: ': aProduction'; cr.	1 to: aRule arity		do: 			[:index |			srcStream				nextPutAll: 'with: arg';				nextPutAll: index printString; cr].	srcStream		cr; tab;		nextPutAll: 'self halt'.	aClass		compile: srcStream contents		classified: 'semantic actions'! !!ActionsBuilder methodsFor: 'meta' stamp: 'jws 11/10/2024 19:31'!declareASTNodeFor: aRule	| nodeClass |	nodeClass := BTASTNode subclass: ('BT', aRule ruleName) asSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-AST'.	nodeClass		compile: (self visitingMethodFor: aRule)		classified: 'visiting'! !!ActionsBuilder methodsFor: 'meta' stamp: 'jws 11/10/2024 19:33'!makeASTNodes	self grammar ruleDeclarations		do:			[:each | self declareASTNodeFor: each]! !!ActionsBuilder methodsFor: 'meta' stamp: 'jws 11/10/2024 19:33'!makeSemanticsClass	| semanticsClass |	semanticsClass := OhmSemanticAction		subclass: (self baseName, 'Actions') asSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'BigTalk-Parser'.	self grammar ruleDeclarations		do:			[:each | self compileActionForRule: each in: semanticsClass]! !!ActionsBuilder methodsFor: 'meta' stamp: 'jws 11/11/2024 11:49'!visitingMethodFor: aRule	^'accept: aVisitor<n><n><t>^aVisitor visitBT<1s>: self' 		expandMacrosWith: aRule ruleName! !!ActionsBuilder methodsFor: 'accessing' stamp: 'jws 11/10/2024 19:30'!baseName	^ baseName! !!ActionsBuilder methodsFor: 'accessing' stamp: 'jws 11/10/2024 19:30'!baseName: anObject	baseName := anObject.! !!ActionsBuilder methodsFor: 'accessing' stamp: 'jws 11/10/2024 19:30'!grammar	^ grammar! !!ActionsBuilder methodsFor: 'accessing' stamp: 'jws 11/10/2024 19:30'!grammar: anObject	grammar := anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ActionsBuilder class	instanceVariableNames: ''!!ActionsBuilder class methodsFor: 'instance creation' stamp: 'jws 11/10/2024 19:35'!baseName: aStringgrammar: aGrammar	^self new		baseName: aString;		grammar: aGrammar;		yourself! !OhmSemanticAction subclass: #BigTalkActions	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Parser'!!BigTalkActions methodsFor: 'utility' stamp: 'jws 11/20/2024 07:17'!unescapeQuotes: aString	| reader writer |	reader := aString readStream.	writer := WriteStream on: String new.	[reader atEnd]		whileFalse: 			[| nextChar |			nextChar := reader next.			(nextChar = $" and: [reader peek = $"])				ifTrue: [reader next].			writer nextPut: nextChar].	^writer contents! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:43'!ArgumentList: aProductionwith: openParenwith: arg1with: commawith: argnwith: closeParen	| firstArg arguments |	firstArg := self value: arg1.	firstArg isNil 		ifTrue: 			[^BTArgumentList new				range: {aProduction interval start. aProduction interval end.};				yourself].	arguments := (self value: argn) 		addFirst: firstArg;		yourself.	^(BTArgumentList arguments: arguments)		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:12'!ArithmeticOperator: aProductionwith: operator	^(BTArithmeticOperator opSymbol: (self value: operator) asSymbol)		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:01'!AssignmentStatement: aProductionwith: variableIdwith: assignmentTokenwith: expression	^(BTAssignmentStatement			variableId: (self value: variableId)			expression: (self value: expression))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:10'!BinaryExpression: aProductionwith: arg1with: operatorwith: arg2	^(BTBinaryExpression			operator: (self value: operator)			arg1: (self value: arg1)			arg2: (self value: arg2))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:03'!BinaryOperator: aProductionwith: operator	^self value: operator! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:02'!CompoundStatement: aProductionwith: openBlockTokenwith: arg2with: closeBlockToken	^(BTCompoundStatement statements: (self value: arg2))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 20:37'!Expression: aProductionwith: expression	^self value: expression! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:02'!Function: aProductionwith: functionTokenwith: identifierwith: parameterListwith: colonTokenwith: returnTypewith: methodBody	^(BTFunction			identifier: (self value: identifier)			parameters: (self value: parameterList)			methodBody: (self value: methodBody)			returnType: (self value: returnType))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:43'!FunctionCall: aProductionwith: identifierwith: arguments	^(BTFunctionCall identifier: (self value: identifier) arguments: (self value: arguments))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:30'!GroupedExpression: aProductionwith: openParenwith: expressionwith: closeParen	^(BTGroupedExpression expression: (self value: expression))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 21:58'!IfThenElseStatement: aProductionwith: ifwith: expressionwith: thenwith: trueStatementwith: elsewith: falseStatement	^(BTIfThenElseStatement			expression: (self value: expression)			trueStatement: (self value: trueStatement)			falseStatement: (self value: falseStatement))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/20/2024 06:27'!IfThenStatement: aProductionwith: ifwith: expressionwith: thenwith: trueStatement	^(BTIfThenStatement			expression: (self value: expression)			trueStatement: (self value: trueStatement))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:26'!LogicalOperator: aProductionwith: operator	^(BTLogicalOperator opSymbol: (self value: operator) asSymbol)		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 21:44'!MethodBody: aProductionwith: variableswith: doTokenwith: statement	| vars |	vars := (self value: variables).	vars isNil ifTrue: [vars := BTVariables new].	^(BTMethodBody variables: vars statement: (self value: statement))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 21:22'!MethodDeclaration: aProductionwith: arg1	^self value: arg1! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:02'!Methods: aProductionwith: methodsTokenwith: methodDeclarations	^(BTMethods declarations: (self value: methodDeclarations))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:27'!ParameterList: aProductionwith: openParenTokenwith: firstParameterwith: commaTokenwith: restOfParameterswith: closeParenToken	| firstParam parameters |	firstParam := self value: firstParameter.	firstParam isNil 		ifTrue: 			[^BTParameterList new				range: {aProduction interval start. aProduction interval end.};				yourself].	parameters := (self value: restOfParameters) 		addFirst: firstParam;		yourself.	^(BTParameterList parameters: parameters)		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:52'!Procedure: aProductionwith: procedureTokenwith: identifierwith: parameterswith: methodBody	^(BTProcedure			identifier: (self value: identifier)			parameters: (self value: parameters)			methodBody: (self value: methodBody))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:59'!ProcedureCall: aProductionwith: identifierwith: arguments	^(BTProcedureCall identifier: (self value: identifier) arguments: (self value: arguments))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:03'!Program: aProductionwith: programTokenwith: variableswith: methodswith: doTokenwith: statement	^(BTProgram			variables: (self value: variables)			methods: (self value: methods)			statement: (self value: statement))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:09'!RelationalOperator: aProductionwith: operator	^(BTRelationalOperator opSymbol: (self value: operator) asSymbol)		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 20:27'!Statement: aProductionwith: aStatement	^self value: aStatement! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:03'!Type: aProductionwith: arg1	^(BTType perform: (self value: arg1) asSymbol)		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:32'!UnaryExpression: aProductionwith: notTokenwith: expression	^(BTUnaryExpression expression: (self value: expression))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:03'!VariableDeclaration: aProductionwith: identifierwith: colonTokenwith: type	^(BTVariableDeclaration			type: (self value: type)			name: (self value: identifier))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:04'!VariableReference: aProductionwith: variableId	^(BTVariableReference identifier: (self value: variableId))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:04'!Variables: aProductionwith: variablesTokenwith: variableDeclarations	^(BTVariables declarations: (self value: variableDeclarations))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 22:56'!WhileStatement: aProductionwith: whilewith: expressionwith: dowith: statement	^(BTWhileStatement expression: (self value: expression) statement: (self value: statement))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:04'!WriteBoolean: aProductionwith: writeBooleanTokenwith: expression	^(BTWriteBoolean expression: (self value: expression))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:04'!WriteInteger: aProductionwith: writeIntegerTokenwith: expression	^(BTWriteInteger expression: (self value: expression))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:06'!WriteLine: aProductionwith: writeLineToken	^(BTWriteLine new)		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/20/2024 07:16'!WriteString: aProductionwith: writeStringTokenwith: expression	^(BTWriteString expression: (self value: expression))		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/12/2024 20:57'!identifier: aProductionwith: identifier	^identifier interval contents! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:38'!literalBoolean: aProductionwith: boolean	^(BTliteralBoolean value: (boolean interval contents) = 'true')		range: {aProduction interval start. aProduction interval end.};		yourself! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/13/2024 07:06'!literalInteger: aProductionwith: signwith: integer	| value |	value := integer interval contents asInteger.	(self value: sign) isNil ifFalse: [value := value negated].	^(BTliteralInteger value: value)		range: {aProduction interval start. aProduction interval end.};		yourself.! !!BigTalkActions methodsFor: 'semantic actions' stamp: 'jws 11/20/2024 07:16'!literalString: aProductionwith: openQuoteTokenwith: stringwith: closeQuoteToken	^(BTliteralString value: (self unescapeQuotes: string interval contents))		range: {aProduction interval start. aProduction interval end.};		yourself! !Object subclass: #BigTalkParser	instanceVariableNames: 'grammar semantics'	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Parser'!!BigTalkParser methodsFor: 'parsing' stamp: 'jws 11/10/2024 19:24'!parse: aStringrule: aGrammarRuleName	| parseTree |	parseTree := self grammar 		matchStream: (OhmInputStream on: aString) 		startingFrom: aGrammarRuleName		failureAsException: true.	^self semantics value: parseTree.! !!BigTalkParser methodsFor: 'accessing' stamp: 'jws 11/10/2024 19:23'!grammar	grammar == nil 		ifTrue: 			[grammar := OhmCompiler compileGrammarDefinition: self class serializedGrammar.			semantics := BigTalkActions new.			grammar semanticAction: semantics].	^grammar! !!BigTalkParser methodsFor: 'accessing' stamp: 'jws 11/10/2024 19:24'!semantics	^semantics! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BigTalkParser class	instanceVariableNames: ''!!BigTalkParser class methodsFor: 'accessing' stamp: 'jws 11/13/2024 11:22'!serializedGrammar	^'BigTalk {    Program    	= "program" Variables? Methods? "do" Statement        Variables        = "variables" VariableDeclaration+            Methods    	= "methods" MethodDeclaration+	VariableDeclaration        = identifier ":" Type       Type        = "string"        | "integer"        | "boolean"          MethodDeclaration    	= Function        | Procedure            Function    	= "function" identifier ParameterList ":" Type MethodBody            Procedure    	= "procedure" identifier ParameterList MethodBody            ParameterList    	= "(" (VariableDeclaration ("," VariableDeclaration)*)? ")"            ArgumentList    	= "(" (Expression ("," Expression)*)? ")"            MethodBody    	= Variables? "do" Statement            Statement   	= CompoundStatement        | WriteString	  | WriteInteger        | WriteBoolean     	  | WriteLine        | IfThenElseStatement        | IfThenStatement        | AssignmentStatement        | WhileStatement        | ProcedureCall            CompoundStatement    	= "[" Statement+ "]"            WriteString    	= "writeString" Expression	    WriteInteger       = "writeInteger" Expression    WriteBoolean        = "writeBoolean" Expression            WriteLine    	= "writeLine"            IfThenElseStatement    	= "if" Expression "then" Statement "else" Statement            IfThenStatement        = "if" Expression "then" Statement            AssignmentStatement    	= identifier "<-" Expression            WhileStatement    	= "while" Expression "do" Statement     UnaryExpression    	= "NOT" Expression            BinaryExpression    	= Expression BinaryOperator Expression        Expression    	= BinaryExpression	  | FunctionCall        | UnaryExpression        | VariableReference        | literalInteger        | literalString        | literalBoolean        | GroupedExpression         GroupedExpression    	= "(" Expression ")"        	VariableReference    	= identifier            FunctionCall    	= identifier ArgumentList           ProcedureCall       = identifier ArgumentList           literalString        = "\"" (~"\"" any | "\"\"")* "\""            literalBoolean    	= "true"        | "false"        identifier    	= ~keyword word            BinaryOperator    	= ArithmeticOperator        | LogicalOperator        | RelationalOperator            ArithmeticOperator       	= "*"        | "/"        | "MOD"        | "+"        | "-"            LogicalOperator    	= "AND"        | "OR"            RelationalOperator    	= "="        | "<"        | ">"            keyword        = "program"        | "procedure"        | "function"        | "do"        | "variables"        | "methods"        | "if"        | "then"        | "else"        | "while"        | "writeInteger"        | "writeString"        | "writeBoolean"        | "writeLine"        | "string"        | "integer"        | "boolean"	  | "true"	  | "false"        | "NOT"        | "AND"        | "OR"        | "MOD"            literalInteger    	= "-"?digit+            word    	= letter alnum*}'! !!BigTalkParser class methodsFor: 'parsing' stamp: 'jws 11/10/2024 19:25'!parse: aString	^self parse: aString rule: 'Program'! !!BigTalkParser class methodsFor: 'parsing' stamp: 'jws 11/10/2024 19:24'!parse: aStringrule: aGrammarRuleName	^self new parse: aString rule: aGrammarRuleName! !TestCase subclass: #BigTalkParserTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'BigTalk-Parser'!!BigTalkParserTestCase methodsFor: 'running' stamp: 'jws 11/13/2024 07:38'!testBooleanNano	| ast |	ast := BigTalkParser parse: self nanoBooleanProgram.	self assert: ast variables declarations isEmpty.	self assert: ast methods declarations isEmpty.! !!BigTalkParserTestCase methodsFor: 'running' stamp: 'jws 11/12/2024 22:43'!testFactorialProgram	| ast |	ast := BigTalkParser parse: self factorialProgram.! !!BigTalkParserTestCase methodsFor: 'running' stamp: 'jws 11/12/2024 20:47'!testNano	| ast |	ast := BigTalkParser parse: self nanoProgram.	self assert: ast variables declarations isEmpty.	self assert: ast methods declarations isEmpty.	self 		assert: 'Hello, World!!'		equals: ast statement expression value! !!BigTalkParserTestCase methodsFor: 'running' stamp: 'jws 11/13/2024 07:08'!testOperatorProgram	| ast |	ast := BigTalkParser parse: self operatorProgram.! !!BigTalkParserTestCase methodsFor: 'running' stamp: 'jws 11/12/2024 22:48'!testProcedureProgram	| ast |	ast := BigTalkParser parse: self procedureProgram.! !!BigTalkParserTestCase methodsFor: 'running' stamp: 'jws 11/12/2024 21:18'!testVariablesProgram	| ast |	ast := BigTalkParser parse: self variablesProgram.	! !!BigTalkParserTestCase methodsFor: 'accessing' stamp: 'jws 11/12/2024 22:24'!factorialProgram	^'program	variables		msg : string	methods		function factorial(n:integer) : integer		do			if n = 0 then				factorial <- 1			else				factorial <- n * factorial( n - 1 )	do		[msg <- "Factorial 5 is "		writeString msg		writeInteger factorial(5)		writeLine]'! !!BigTalkParserTestCase methodsFor: 'accessing' stamp: 'jws 11/13/2024 07:35'!nanoBooleanProgram	^'program do writeBoolean true'! !!BigTalkParserTestCase methodsFor: 'accessing' stamp: 'jws 11/12/2024 20:19'!nanoProgram	^'program do writeString "Hello, World!!"'! !!BigTalkParserTestCase methodsFor: 'accessing' stamp: 'jws 11/13/2024 07:21'!operatorProgram	^'program	do		if (9 > 7) AND (NOT (true = false)) OR ("hello" < "abc") then			writeInteger (((7 + 3)*(8 - 2)) MOD 7) / 2'! !!BigTalkParserTestCase methodsFor: 'accessing' stamp: 'jws 11/12/2024 22:49'!procedureProgram	^'program	methods    		procedure sayHello()    		do        		writeString "Hello, World!!"        		procedure countdown(count:integer, message:string)    		variables         		counter:integer    		do        		[counter <- count            	while counter > 0 do	            	[counter <- counter - 1                		writeInteger counter]            	writeString message            	writeLine]           	do		[sayHello()		countdown(10, "Blastoff!!")]'! !!BigTalkParserTestCase methodsFor: 'accessing' stamp: 'jws 11/12/2024 20:51'!variablesProgram	^'program	variables		answer : integer		msg : string		isIt : boolean	do		[answer <- 42		writeInteger answer		writeLine		msg <- "Hello, World!!"		writeString msg		writeLine		isIt <- true		writeBoolean isIt		writeLine]'! !